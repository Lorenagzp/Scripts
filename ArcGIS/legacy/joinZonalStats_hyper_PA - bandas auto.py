# -*- coding: utf-8 -*-
# ---------------------------------------------------------------------------
# joinZonalStats_hyper_BW_pruebas.py
# Created on: 2014-06-07 11:06:16.00000
#   (generated by ArcGIS/ModelBuilder)
# Usage: joinZonalStats_hyper_BW_pruebas <Buffer> <Stats_table> <Grid> <Zone_field_and_join_Field> <Field_Name_Calculate_field> <Expression_Calculate_field> <Expression> <band> <Raster_set> 
# Description:
#This script takes 3 inputs:
#Buffer: zone feature to use as input for zonal statistic tool
#Grid: feature whose table will be used to save the mean values of the zonal statistic tool.
#   This should contain the same features ID field than the "Buffer" input.
#   A field named B1, B2... will be created to store the mean values for each zone for each band. 
#Raster: Raster to use as input for zonal statistic tool, along with the "Buffer".
#	The band information is read from the envi HDR file
###The temporal stats tables are created in the default ArcGIS GDB
# ---------------------------------------------------------------------------

# Import arcpy module
import os
import arcpy, arcgisscripting
import itertools
import re
import traceback, sys

def print_kwinfo():
    if deb==1:
        print "kwinfo se guarda:"
        print kwinfo

def create_if_not_exists(path):
    try:
        if not os.path.exists(path):
            os.makedirs(path)
    except Exception, e:
        # If an error occurred, print line number and error message
        tb = sys.exc_info()[2]
        arcpy.AddMessage("Line:" + str(tb.tb_lineno))
        arcpy.AddMessage("Error " + e.message)

def exists(path):
    exists = True if os.path.exists(path)else False
    return exists 

def replace_in_list(regex,lst):
    return [re.sub(regex, '', x).strip() for x in lst] #List comprehension

def print_dict(dictio):
    #The next line iterates, formats and prints the dictionary, key:value
    #print "\n".join('{}={}'.format(k,v) for k,v in dictio.items()) print in console
    arcpy.AddMessage("\n".join('{}={}'.format(k,v) for k,v in dictio.items()))#Print to arcmap results window

def letsgo(header_file):
    arcpy.AddMessage("started reading header file:" + str(header_file))
    envi_header_keywords={"acquisition time","band names","bands",
                          "bbl","byte order","class lookup","class names",
                          "classes","cloud cover","complex function",
                          "coordinate system string","data gain values",
                          "data ignore value","data offset values",
                          "data reflectance gain values","data reflectance offset values",
                          "data type","default bands","default stretch","dem band",
                          "dem file","description","file type","fwhm","geo points",
                          "header offset","interleave","lines","map info",
                          "major frame offsets","minor frame offsets","pixel size",
                          "product type","projection info","read procedures",
                          "reflectance scale factor","rpc info","samples","security tag",
                          "sensor type","solar irradiance","spectra names","sun azimuth",
                          "sun elevation","wavelength","wavelength units","x start",
                          "y start","z plot average","z plot range","z plot titles"}
    envi_header_keywords_or="|".join(envi_header_keywords)
    # Read and Iterate over the lines of the file
    with open(header_file, 'rt') as f:
        data = f.read()[5:]
    lines = re.split(r"[\n]", data)#the info corresponding to one line
    arcpy.AddMessage("Finished reading header lines")
    dictio = {}
    global deb
    deb=0
    wl=[]#List to save wavelengths
    bn=[]#List to save band names
    clines=[]#complete lines with all the info corresponding to one header keyword
    ongoing=0 #Variable para marcar si se está buscando el resto de la línea de info
    #to one header keyword is not in one single line
    kwinfo=""
    for i,l in enumerate(lines):
        if deb==1: print str(i)+"-l- "+str(l)
        kwinfo+=l
        if deb==1: print str(i)+"-kwinfo- "+str(kwinfo)
        if ongoing==1:
            if "}" in l:
                if deb==1: print "ongoing==se cierra por fin el parentesis"
                print_kwinfo()
                clines.append(kwinfo)
                kwinfo=""
                ongoing=0
                continue
            else:
                if deb==1: print "ongoing==1 else"
        if ongoing==0:
            ongoing=1
            for keyw in envi_header_keywords:
                if keyw in l:
                    if deb==1: print keyw+" attribute found"
                    if "{" in l:
                        if "}" in l:
                            if deb==1: print "ongoing==parentesis cerrando en linea"
                            print_kwinfo()
                            clines.append(kwinfo)
                            kwinfo=""
                            ongoing=0
                        else:
                            if deb==1: print "if bracket in l: --- else"
                    else:
                        if deb==1: print "ongoing==sin paretesis"
                        print_kwinfo()
                        clines.append(kwinfo)
                        kwinfo=""
                        ongoing=0
        if deb==1: print "fin de ronda de for"
    for cl in clines:
        #expresion to filter how to sepatate the string.
        regexpresion = re.compile(r"""(.+?)\s*=\s*(.+)""")
        dictio.update(dict(regexpresion.findall(cl)))
        if deb==1: print regexpresion.findall(cl)
    for key in dictio: dictio[key]=dictio[key].strip()
    print "Header attributes:"
    arcpy.AddMessage("Header attributes read")
    print_dict(dictio)
    expr_replace = re.compile(r"{|}") #Expression to remove brackets below
    #wavelength
    if "wavelength" in dictio:
        wl=re.split(r"[,]", dictio["wavelength"])
        wl =replace_in_list(expr_replace,wl)
        arcpy.AddMessage(wl)
        arcpy.AddMessage("saved wl")
    #Band names
    if "band names" in dictio:
        arcpy.AddMessage("band names attribute found")
        bn=re.split(r"[,]", dictio["band names"])
        arcpy.AddMessage("split competed")
        bn=replace_in_list(expr_replace,bn)
        arcpy.AddMessage("saved bn")
    #Next we add the wl units only if they are defined
    arcpy.AddMessage("Format composed band name")
    if "wavelength units" in dictio:
        if "band names" in dictio and "wavelength" in dictio:
            join_str = '{bandn} ({waveln} '+dictio["wavelength units"]+')' if dictio["wavelength units"]!="Unknown" else '{bandn} ({waveln})'
            arcpy.AddMessage("bn and wl found")
            full_bn= '\n'.join(join_str.format(bandn=b, waveln=w) for b,w in itertools.izip(bn, wl)).split('\n')
        if not "band names" in dictio and "wavelength" in dictio:
            join_str = '{waveln} '+dictio["wavelength units"] if dictio["wavelength units"]!="Unknown" else '{waveln}'
            arcpy.AddMessage("wl found+units")
            full_bn= '\n'.join(join_str.format(waveln=w) for w in wl).split('\n')
    else:
        if "band names" in dictio and "wavelength" in dictio:
            join_str = '{bandn} ({waveln})'
            arcpy.AddMessage("bn and wl found")
            full_bn= '\n'.join(join_str.format(bandn=b, waveln=w) for b,w in itertools.izip(bn, wl)).split('\n')
        if not "band names" in dictio and "wavelength" in dictio:
            arcpy.AddMessage("wl found")
            full_bn= wl
    arcpy.AddMessage(full_bn)
    if deb==1:
        print full_bn
        print "Bands: "+len(full_bn)
    arcpy.AddMessage("Finished reading header") 
    return full_bn

##def save_bn_wl():
##    full_bn= '\n'.join(join_str.format(bandn=b, waveln=w) for b,w in itertools.izip(bn, wl)).split('\n')
##
##def save_wl():
##    full_bn= '\n'.join(join_str.format(waveln=w) for w in itertools.izip(wl)).split('\n')
    
##        Starts the script
try:
    # Check out any necessary licenses
    arcpy.CheckOutExtension("spatial")

    # Create the Geoprocessor object
    gp = arcgisscripting.create()
           
    # Load required toolboxes
    print "Start!"
    #Type: Feature layer -buffer for the zonalStats
    bf_Lx_1 = arcpy.GetParameterAsText(0)
    L_merge = bf_Lx_1
    arcpy.AddMessage("read b1 " + bf_Lx_1)
    print bf_Lx_1

    #Type: Field -ID field
    f = arcpy.GetParameterAsText(0)
    L_merge = bf_Lx_1
    arcpy.AddMessage("read b1 " + bf_Lx_1)
    print bf_Lx_1

    #type: Feature layer - Feature in whose table the stats will be stored
    Grid = arcpy.GetParameterAsText(1)
    arcpy.AddMessage("read " + Grid)
    desc = arcpy.Describe(Grid)
    gPath = desc.path
    gridSource = str(gPath) + "\\" + Grid
    arcpy.AddMessage("Grid source: " + gridSource)
    gridName = desc.baseName
    arcpy.AddMessage("Grid basename: " + gridName)
    
    print Grid
    #type: Raster layer
    Raster = arcpy.GetParameterAsText(2)
    arcpy.AddMessage("read " + Raster)
    desc = arcpy.Describe(Raster)
    rPath = desc.path
    Raster = str(rPath) + "\\" + desc.baseName+ "." +desc.extension
    arcpy.AddMessage("Raster source: " + Raster)
    print Raster

    #type: Field - Field for join and statistics
    id_field = arcpy.GetParameterAsText(3)
    arcpy.AddMessage("read " + id_field)

    #List of band names
    hdr_file = os.path.join(str(rPath) + "\\" + desc.baseName+".hdr") 
    bandNames = letsgo(hdr_file)
    #Next I was try ing to print the band number. Not yet
    if type(bandNames).__name__ != 'int':
        print r"# of bands in raster: "+str(len(bandNames))

    #Folder to store the tables with the stats  
    tempGdb_path = r"C:\Users\usuario\Documents\ArcGIS" 
    tempGdb = r"Default.gdb"
    #This is the path
    tablesPath = os.path.join(tempGdb_path, tempGdb)
    #Keep the individual stats tables?
    #Either way the MEAN is stored to the table of the grid feature selected
    keep_tables=False
    # Execute CreateFileGDB
    create_if_not_exists(tempGdb_path)
    if not exists(tablesPath):
        arcpy.CreateFileGDB_management(tempGdb_path, tempGdb)
    print tablesPath
        
    # Local variables:
    arcpy.AddMessage("Local variables")
    print "Local variables"
    Zone_field_and_join_Field = id_field
    gridLayer = "gridLayer"
    

    ## Make a layer
    print "Make layer"
    arcpy.MakeFeatureLayer_management(Grid, "gridLayer")

    i=1
    for b in bandNames:
        arcpy.AddMessage("b: " + b)
        band = Raster + "\\" + b
        arcpy.AddMessage("band: " + band)
        bandField = "B" + str(i)
        print bandField
        #Set table name
        tableName = gridName + "_" + bandField #+ ".dbf"
        L_Stats_table = tablesPath + "\\" + tableName
        print L_Stats_table
        Field_Name_Calculate_field = gridName + "." + bandField
        print Field_Name_Calculate_field
        Expression_Select_layer = tableName+".Mean IS NOT NULL"
        # Use this if the stats were saved to a dbf file "\""+tableName+".Mean\" IS NOT NULL"
        # Use this if the stats were saved to a table "\""+tableName+":Mean\" IS NOT NULL"
        # Use this if the stats were saved to a database table tableName+".Mean IS NOT NULL"
        print Expression_Select_layer
        Expression_Calculate_field = "round(!"+tableName+".Mean!,0)"
        #the "!"+tableName+":Mean!" notation (:)is used when the stats are saved to a table
        #the "!"+tableName+".Mean!" notation (.)is used when the stats are saved to a dbf file
        print Expression_Calculate_field
        
        # Process: Zonal Statistics as Table
        print "Zonal statistics..."
        #Perform the zonalstatistics getting only the "MEAN" value of the cells
        #"MEAN" can be changed to get different statistics:
        #ALL,MEAN,MAJORITY,MAXIMUM,MEDIAN,MINIMUM,MINORITY,RANGE,STD,SUM,VARIETY,MIN_MAX,MEAN_STD,MIN_MAX_MEAN 
        #arcpy.AddMessage("zs exists? : " + str(exists(path)))
        zs = arcpy.gp.ZonalStatisticsAsTable_sa(L_merge, Zone_field_and_join_Field, band, L_Stats_table, "DATA", "MEAN")
        arcpy.AddMessage("stats table: " + str(zs))
        fields = gp.ListFields(gridLayer, bandField)
        field_found = fields.Next()
        if (not field_found):
            arcpy.AddField_management(gridLayer, bandField, "FLOAT", 10, 3, "", "", "NULLABLE", "NON_REQUIRED", "")
            arcpy.AddMessage("Added. Before field not found " + str(bandField))
        else:
            arcpy.AddMessage("field_found " + str(field_found.name))
            arcpy.AddMessage("field found " + str(bandField))
        
        # Process: Add Join
        print "Joining..."
        arcpy.AddMessage("grid..."+ gridLayer)
        arcpy.AddMessage("field..."+Zone_field_and_join_Field)
        arcpy.AddJoin_management(gridLayer, Zone_field_and_join_Field, zs, Zone_field_and_join_Field, "KEEP_ALL")    

        # Process: Select Layer By Attribute
        if i==1:
            print "Selecting Layer..."
            gridLayerSelection = arcpy.SelectLayerByAttribute_management(gridLayer, "NEW_SELECTION", Expression_Select_layer)

        # Process: Calculate Field
        print "Calculating field"
        arcpy.AddMessage("Calculating field...")   
        arcpy.CalculateField_management(gridLayerSelection, Field_Name_Calculate_field, Expression_Calculate_field, "PYTHON")

        # Process: Remove Join
        arcpy.AddMessage("remove Join")
        arcpy.RemoveJoin_management(gridLayer, "")
        #Erase stats table
        if not keep_tables: arcpy.Delete_management(zs)        
        i+=1
              
    print "Finish"

except Exception, e:
    # If an error occurred, print line number and error message
    import traceback, sys
    tb = sys.exc_info()[2]
    arcpy.AddMessage("Line:" + str(tb.tb_lineno))
    arcpy.AddMessage("Error " + e.message)
    print "OMG!"
  

